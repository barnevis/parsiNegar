# مستندات فنی پارسی‌نگار

این سند به تشریح معماری، ساختار و جریان داده در پروژه پارسی‌نگار می‌پردازد. هدف آن ارائه یک دید کلی برای توسعه‌دهندگان جدید و درک عمیق‌تر از نحوه عملکرد برنامه است.

## ۱. نمای کلی معماری

پارسی‌نگار بر اساس یک **معماری ماژولار و رویداد-محور (Event-Driven)** با یک **رابط کاربری مبتنی بر کامپوننت و بارگذاری پویا (Component-Based UI & Dynamic Loading)** ساخته شده است. این رویکرد به جداسازی مسئولیت‌ها (Separation of Concerns) کمک کرده و توسعه و نگهداری کد را آسان‌تر می‌کند.

- **ماژولار (Modular):** هر بخش از برنامه (مانند ویرایشگر، پیش‌نمایش، مدیریت فایل) در یک ماژول جداگانه قرار دارد. این ماژول‌ها تا حد امکان مستقل از یکدیگر عمل می‌کنند.
- **رویداد-محور (Event-Driven):** به جای اینکه ماژول‌ها مستقیماً یکدیگر را فراخوانی کنند، از طریق یک گذرگاه رویداد مرکزی (`EventBus`) با هم ارتباط برقرار می‌کنند. برای مثال، وقتی کاربر متنی را در ویرایشگر تایپ می‌کند، ماژول ویرایشگر یک رویداد `editor:contentChanged` را منتشر می‌کند. سپس ماژول‌های دیگر مانند پیش‌نمایش، نوار وضعیت و ذخیره‌سازی خودکار به این رویداد گوش داده و وظایف خود را انجام می‌ده دهند.
- **رابط کاربری مبتنی بر کامپوننت و بارگذاری پویا:** ساختار `index.html` به یک پوسته حداقلی کاهش یافته است. تمام اجزای رابط کاربری (UI) - از جمله منوها، نوارهای ابزار و مودال‌ها - به صورت کامپوننت‌های جاوااسکریپت مجزا تعریف شده و تنها در صورت نیاز به صورت پویا در DOM بارگذاری و تزریق می‌شوند. این کار توسط یک مدیر UI مرکزی (`UIManager`) هماهنگ می‌شود که عملکرد اولیه برنامه را بهبود بخشیده و ساختار کد را بسیار تمیزتر می‌کند.

## ۲. ساختار پوشه‌ها

ساختار پروژه به شکل زیر سازماندهی شده است:

```
.
├── assets/
│   ├── css/          # فایل‌های استایل (CSS) به صورت ماژولار
│   └── pic/          # تصاویر و آیکون‌ها
├── doc/              # مستندات پروژه (فنی و کاربری)
├── js/
│   ├── core/         # ماژول‌های هسته اصلی برنامه
│   ├── features/     # ماژول‌های مربوط به ویژگی‌های برنامه
│   ├── markdown/     # منطق مربوط به پردازش مارک‌داون
│   ├── ui/           # مدیریت و کامپوننت‌های رابط کاربری
│   │   ├── components/ # فایل‌های مجزای کامپوننت‌های HTML
│   │   └── uiManager.js # مدیر بارگذاری کامپوننت‌ها
│   └── utils/        # توابع و ابزارهای کمکی
├── libs/             # کتابخانه‌های جانبی (مانند پارس‌نشان)
├── index.html        # فایل اصلی HTML
└── ...
```

- **`js/core`**: شامل ستون فقرات برنامه است: `app.js` (نقطه شروع)، `editor.js` (منطق ویرایشگر)، `eventBus.js` (سیستم ارتباطی) و `state.js` (وضعیت کلی برنامه).
- **`js/features`**: هر فایل در این پوشه یک ویژگی خاص از برنامه را پیاده‌سازی می‌کند (مانند `search.js`, `settings.js`, `fileManager.js`).
- **`js/ui`**: این پوشه جدید، مسئولیت تمام منطق مربوط به رابط کاربری را بر عهده دارد.
    - **`components/`**: هر فایل در اینجا یک قطعه از HTML برنامه را به عنوان یک ماژول جاوااسکریپت صادر می‌کند (مانند `menuBar.js`, `settingsModal.js`).
    - **`uiManager.js`**: ارکستراتور مرکزی برای بارگذاری و تزریق این کامپوننت‌ها به DOM است.
- **`js/utils`**: شامل توابع کمکی عمومی مانند انتخاب‌گرهای DOM، ذخیره‌سازی در IndexedDB و توابع کمکی دیگر است.

## ۳. ماژول‌های اصلی (Core Modules)

### `app.js`
نقطه ورود اصلی برنامه است. وظیفه آن ایجاد یک نمونه از کلاس `ParsiNegarApp` است. فرآیند مقداردهی اولیه آن اکنون **ناهمزمان (asynchronous)** است و شامل مراحل زیر است:
1.  تزریق مستقیم پوسته اصلی (Layout Shell) به DOM.
2.  منتظر ماندن برای چرخه رندر بعدی مرورگر جهت اطمینان از آماده بودن DOM.
3.  استفاده از `UIManager` برای بارگذاری متوالی کامپوننت‌های اصلی UI (منو، نوار ابزار و...).
4.  مقداردهی اولیه تمام ماژول‌های ویژگی (`features`).

### `uiManager.js`
این ماژول جدید، قلب سیستم رابط کاربری پویا است. مسئولیت‌های آن عبارتند از:
- **ثبت کامپوننت‌ها:** نگهداری یک رجیستری از تمام کامپوننت‌های UI، محل تزریق آن‌ها و نحوه بارگذاری‌شان.
- **بارگذاری عنداللزوم (Lazy Loading):** استفاده از `import()` پویا برای بارگذاری ماژول کامپوننت فقط در اولین باری که به آن نیاز است.
- **تزریق به DOM:** قرار دادن HTML کامپوننت در عنصر هدف صحیح.
- **مدیریت Race Condition:** استفاده از یک سیستم کش برای پرامیس‌ها تا از بارگذاری چندباره یک کامپوننت در صورت کلیک‌های سریع کاربر جلوگیری شود.

### `editor.js`
این کلاس تمام تعاملات با عنصر `<textarea>` را مدیریت می‌کند. مسئولیت‌های آن عبارتند از:
- مدیریت تاریخچه برای واگرد/ازنو (Undo/Redo).
- رسیدگی به رویدادهای ورودی و صفحه‌کلید (مانند Tab، تکمیل خودکار جفت‌ها).
- پیاده‌سازی کلیدهای میانبر برای قالب‌بندی متن.
- انتشار رویداد `editor:contentChanged` هنگام تغییر محتوا.

### `eventBus.js`
یک پیاده‌سازی ساده از الگوی انتشار/اشتراک (Pub/Sub) است. این ماژول به عنوان یک هماهنگ‌کننده مرکزی عمل می‌کند و به ماژول‌ها اجازه می‌دهد بدون وابستگی مستقیم با یکدیگر ارتباط برقرار کنند.

### `state.js`
یک مخزن مرکزی برای نگهداری وضعیت کلی برنامه است که بین ماژول‌های مختلف به اشتراک گذاشته می‌شود. مواردی مانند `currentFileId` (شناسه فایل فعلی) در این ماژول نگهداری می‌شوند.

## ۴. ماژول‌های ویژگی و جریان رویدادها

این بخش به بررسی نحوه تعامل ماژول‌ها با سیستم جدید UI می‌پردازد.

### مثال: باز کردن مودال تنظیمات

1.  **کاربر** روی دکمه تنظیمات در نوار فعالیت کلیک می‌کند.
2.  شنونده رویداد در **`activityBar.js`** یک رویداد `settings:open` منتشر می‌کند.
3.  **`settings.js`** به این رویداد گوش می‌دهد و تابع `openSettingsPanel` را فراخوانی می‌کند.
4.  درون `openSettingsPanel`، اولین دستور `await uiManager.ensureComponentLoaded('settingsModal')` است.
5.  **`uiManager`** بررسی می‌کند که آیا مودال تنظیمات قبلاً بارگذاری شده است یا خیر. اگر نه:
    - با استفاده از `import()`، ماژول `js/ui/components/settingsModal.js` را بارگذاری می‌کند.
    - رشته HTML صادر شده از ماژول را به انتهای `<body>` تزریق می‌کند.
    - پرامیس با موفقیت به پایان می‌رسد.
6.  اکنون که `uiManager` کار خود را تمام کرده، **`settings.js`** مطمئن است که عناصر مودال (مانند `#settingsPanel`) در DOM وجود دارند و می‌تواند با خیال راحت به آن‌ها دسترسی پیدا کرده و مودال را نمایش دهد.

این جریان تضمین می‌کند که HTML مودال تنظیمات فقط زمانی دانلود و به صفحه اضافه می‌شود که کاربر واقعاً قصد استفاده از آن را داشته باشد.

## ۵. جریان داده (Data Flow)

یک مثال از جریان داده در برنامه، فرآیند تایپ توسط کاربر است:

1.  **کاربر** متنی را در `<textarea>` تایپ می‌کند.
2.  **`editor.js`** رویداد `input` را دریافت کرده و یک رویداد `editor:contentChanged` را از طریق `EventBus` منتشر می‌کند.
3.  **`preview.js`** به این رویداد گوش می‌دهد، محتوای جدید را دریافت کرده و آن را به HTML رندر می‌کند.
4.  **`statusBar.js`** به این رویداد گوش می‌دهد و آمار متن (تعداد کلمات، حروف و...) را به‌روزرسانی می‌کند.
5.  **`autoSave.js`** به این رویداد گوش می‌دهد و پس از یک تأخیر کوتاه (debounce)، محتوا را در IndexedDB و localStorage ذخیره می‌کند.
6.  **`sidePanel.js`** (به‌طور خاص بخش TOC) به این رویداد گوش می‌دهد و فهرست مطالب را به‌روزرسانی می‌کند.

این جریان یک‌طرفه و مبتنی بر رویداد، کد را قابل پیش‌بینی و اشکال‌زدایی آن را آسان‌تر می‌کند.

## ۶. پردازش مارک‌داون

منطق پردازش در پوشه `js/markdown` قرار دارد:

- **`parser.js`**: به عنوان یک **نما (Facade)** عمل می‌کند. این ماژول بر اساس انتخاب کاربر در تنظیمات، یکی از مفسرهای (Marked.js, Parsneshan) را برای تبدیل مارک‌داون به HTML انتخاب و استفاده می‌کند. این کار باعث می‌شود بقیه برنامه نیازی به دانستن جزئیات مفسر فعلی نداشته باشد.
- **`highlighter.js`**: مسئولیت مدیریت هایلایت کردن سینتکس کد (با استفاده از `highlight.js`) و رندر نمودارها (با استفاده از `mermaid.js`) را بر عهده دارد.

## ۷. پشته فنی (Technical Stack)

پارسی‌نگار با استفاده از مجموعه‌ای از فناوری‌ها و کتابخانه‌های مدرن وب ساخته شده است تا تجربه‌ای سبک، سریع و قدرتمند را ارائه دهد. در ادامه، اجزای اصلی این پشته فنی تشریح شده‌اند.

### فناوری‌های هسته (Core Technologies)

- **HTML5, CSS3, JavaScript (ES6 Modules):**
  اسکلت اصلی برنامه بر پایه استانداردهای وب و بدون استفاده از فریمورک‌های سنگین (مانند React یا Vue) ساخته شده است. این رویکرد "Vanilla JS" به ما اجازه می‌دهد تا کنترل کاملی بر عملکرد برنامه داشته باشیم و حجم نهایی آن را به حداقل برسانیم. کد جاوااسکریپت با استفاده از ماژول‌های ES6 سازماندهی شده است که به تفکیک بهتر کد و نگهداری آسان‌تر آن کمک می‌کند.

### پردازش مارک‌داون و رندر (Markdown Processing & Rendering)

برنامه از یک معماری چند-مفسری پشتیبانی می‌کند که به کاربر اجازه می‌دهد موتور پردازش مارک‌داون را انتخاب کند:

- **markdown-it:** یک مفسر مارک‌داون مدرن و بسیار قابل توسعه که به عنوان پایه و اساس مفسر سفارشی «پارس‌نشان» عمل می‌کند.
- **Marked.js:** یک مفسر سریع و سبک برای پردازش مارک‌داون استاندارد.
- **شه‌نشان (ShahNeshan):** مفسر دیگری که برای پردازش بهینه متون فارسی طراحی شده است.
- **پارس‌نشان (Parsneshan):** این یک کتابخانه سفارشی (`libs/parsneshan.js`) است که بر پایه `markdown-it` ساخته شده و قابلیت‌های پیشرفته‌ای مانند **جعبه‌های توضیحی**، **شعر**، **برجسته کردن متن** و پشتیبانی از **بازبینه‌ها (Task Lists)** را به برنامه اضافه می‌کند.

### نمایش کد و نمودار (Code & Diagram Rendering)

- **highlight.js:** برای هایلایت کردن سینتکس بلوک‌های کد در زبان‌های مختلف برنامه‌نویسی استفاده می‌شود. این کتابخانه خوانایی کدها را به شدت افزایش می‌دهد.
- **Mermaid.js:** یک ابزار قدرتمند که به کاربران اجازه می‌دهد تنها با نوشتن متن، نمودارها و دیاگرام‌های پیچیده (مانند فلوچارت، نمودار توالی و نقشه‌ذهنی) را رسم کنند.

### ذخیره‌سازی سمت کاربر (Client-Side Storage)

- **IndexedDB:** برای ذخیره‌سازی پایدار فایل‌های کاربر به صورت محلی در مرورگر استفاده می‌شود. این پایگاه داده سمت کاربر به برنامه اجازه می‌دهد تا حجم زیادی از داده‌ها را ذخیره کرده و حتی به صورت آفلاین نیز کار کند. تمام فایل‌ها و محتوای آن‌ها در IndexedDB نگهداری می‌شوند.
- **localStorage:** برای ذخیره‌سازی تنظیمات کاربر (مانند قالب، فونت) و آخرین وضعیت برنامه (فایل باز شده اخیر) استفاده می‌شود. این کار باعث می‌شود تجربه کاربری در بازدیدهای مجدد یکپارچه و شخصی‌سازی شده باشد.

### ابزارهای خروجی و فایل (Exporting & File Utilities)

- **html2pdf.js:** این کتابخانه برای پیاده‌سازی قابلیت خروجی گرفتن به فرمت PDF از پیش‌نمایش HTML استفاده می‌شود.
- **JSZip:** برای فعال‌سازی قابلیت «خروجی گرفتن از تمام فایل‌ها» به صورت یک فایل فشرده (`.zip`) به کار می‌رود.

### رابط کاربری و آیکون‌ها (UI & Icons)

- **Font Awesome:** برای تامین مجموعه گسترده‌ای از آیکون‌های باکیفیت که در سراسر رابط کاربری (منوها، نوار ابزار و دکمه‌ها) استفاده شده‌اند.
- **emoji-picker-element:** یک وب کامپوننت (Web Component) سبک و سریع برای ارائه یک انتخابگر شکلک (Emoji) مدرن و قابل شخصی‌سازی. این کتابخانه به کاربران اجازه می‌دهد به راحتی شکلک‌ها را جستجو و در متن خود درج کنند.